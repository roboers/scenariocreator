/**
 * Northwave Resilience Scenario Builder
 * Main Application File
 */

// Global application state
const APP_STATE = {
    currentPhase: 'setup',
    scenario: {
        // Will be populated after setup
        params: {},
        phases: {},
        injects: []
    },
    navigationHistory: [],
    apiSettings: {
        apiKey: localStorage.getItem('nw_api_key') || '',
        endpoint: localStorage.getItem('nw_api_endpoint') || '',
        deployment: localStorage.getItem('nw_api_deployment') || '',
        apiVersion: localStorage.getItem('nw_api_version') || '2023-05-15'
    }
};

// Phase definitions
const PHASES = {
    setup: {
        id: 'setup',
        name: 'Setup',
        description: 'Configure the basic parameters for your incident response scenario',
        icon: 'fas fa-cog',
        order: 1
    },
    identification: {
        id: 'identification',
        name: 'Identification',
        description: 'The process of determining whether an incident has occurred and its scope',
        icon: 'fas fa-search',
        order: 2
    },
    containment: {
        id: 'containment',
        name: 'Containment',
        description: 'Limiting the scope and magnitude of an incident',
        icon: 'fas fa-shield-alt',
        order: 3
    },
    eradication: {
        id: 'eradication',
        name: 'Eradication',
        description: 'Removing the threat from the environment',
        icon: 'fas fa-virus-slash',
        order: 4
    },
    recovery: {
        id: 'recovery',
        name: 'Recovery',
        description: 'Restoring systems to normal operation',
        icon: 'fas fa-sync',
        order: 5
    },
    hardening: {
        id: 'hardening',
        name: 'Hardening',
        description: 'Implementing lessons learned and improving security posture',
        icon: 'fas fa-shield-virus',
        order: 6
    }
};

// Event types for custom inject selection
const EVENT_TYPES = {
    technical: [
        {
            id: 'phishing',
            name: 'Phishing Email',
            icon: 'fas fa-envelope',
            category: 'email',
            description: 'A suspicious email that may contain malicious links or attachments'
        },
        {
            id: 'security-alert',
            name: 'Security Alert',
            icon: 'fas fa-bell',
            category: 'alert',
            description: 'An alert generated by a security monitoring system'
        },
        {
            id: 'user-report',
            name: 'User Report',
            icon: 'fas fa-user',
            category: 'report',
            description: 'A report from a user about a suspicious activity or issue'
        },
        {
            id: 'system-log',
            name: 'System Log',
            icon: 'fas fa-file-alt',
            category: 'log',
            description: 'A log entry from a system showing relevant activity'
        },
        {
            id: 'malware-detection',
            name: 'Malware Detection',
            icon: 'fas fa-bug',
            category: 'alert',
            description: 'Detection of malware or suspicious code on a system'
        }
    ],
    business: [
        {
            id: 'media-inquiry',
            name: 'Media Inquiry',
            icon: 'fas fa-newspaper',
            category: 'media',
            description: 'An inquiry from a media outlet about the incident'
        },
        {
            id: 'business-impact',
            name: 'Business Impact',
            icon: 'fas fa-chart-line',
            category: 'business',
            description: 'Information about how the incident is affecting business operations'
        },
        {
            id: 'customer-impact',
            name: 'Customer Impact',
            icon: 'fas fa-users',
            category: 'business',
            description: 'Information about how the incident is affecting customers'
        },
        {
            id: 'regulatory-notification',
            name: 'Regulatory Notification',
            icon: 'fas fa-gavel',
            category: 'legal',
            description: 'A notification that must be sent to regulatory authorities'
        },
        {
            id: 'executive-update',
            name: 'Executive Update',
            icon: 'fas fa-briefcase',
            category: 'management',
            description: 'An update from or for the executive management team'
        }
    ],
    effect: [
        {
            id: 'workaround',
            name: 'Business Workaround',
            icon: 'fas fa-tools',
            category: 'workaround',
            description: 'A temporary workaround for affected business processes'
        },
        {
            id: 'workforce',
            name: 'Workforce Management',
            icon: 'fas fa-people-arrows',
            category: 'workforce',
            description: 'Managing staff during the incident (relocation, remote work, etc.)'
        },
        {
            id: 'communication',
            name: 'Stakeholder Communication',
            icon: 'fas fa-comments',
            category: 'communication',
            description: 'Communication to stakeholders about the incident'
        },
        {
            id: 'recovery-action',
            name: 'Recovery Action',
            icon: 'fas fa-redo',
            category: 'recovery',
            description: 'An action taken to recover affected systems or processes'
        },
        {
            id: 'red-herring',
            name: 'Red Herring',
            icon: 'fas fa-fish',
            category: 'false-lead',
            description: 'A false lead that might distract from the actual incident'
        }
    ]
};

// Initialize the application
document.addEventListener('DOMContentLoaded', function() {
    console.log('Resilience Scenario Builder initializing...');
    
    // Load API settings from localStorage
    loadApiSettings();
    
    // Load the current phase
    loadPhase(APP_STATE.currentPhase);
    
    // Set up event listeners
    setupEventListeners();
    
    // Initialize modules
    initializeModules();
});

/**
 * Load API settings from localStorage
 */
function loadApiSettings() {
    const apiKey = localStorage.getItem('nw_api_key');
    const endpoint = localStorage.getItem('nw_api_endpoint');
    const deployment = localStorage.getItem('nw_api_deployment');
    const apiVersion = localStorage.getItem('nw_api_version');
    
    if (apiKey) document.getElementById('api-key').value = apiKey;
    if (endpoint) document.getElementById('api-endpoint').value = endpoint;
    if (deployment) document.getElementById('api-deployment').value = deployment;
    if (apiVersion) document.getElementById('api-version').value = apiVersion || '2023-05-15';
    
    APP_STATE.apiSettings = {
        apiKey: apiKey || '',
        endpoint: endpoint || '',
        deployment: deployment || '',
        apiVersion: apiVersion || '2023-05-15'
    };
}

/**
 * Save API settings to localStorage
 */
function saveApiSettings() {
    const apiKey = document.getElementById('api-key').value;
    const endpoint = document.getElementById('api-endpoint').value;
    const deployment = document.getElementById('api-deployment').value;
    const apiVersion = document.getElementById('api-version').value;
    
    localStorage.setItem('nw_api_key', apiKey);
    localStorage.setItem('nw_api_endpoint', endpoint);
    localStorage.setItem('nw_api_deployment', deployment);
    localStorage.setItem('nw_api_version', apiVersion);
    
    APP_STATE.apiSettings = {
        apiKey,
        endpoint,
        deployment,
        apiVersion
    };
}

/**
 * Set up global event listeners
 */
function setupEventListeners() {
    // Phase navigation
    document.querySelectorAll('.phase-item').forEach(item => {
        item.addEventListener('click', function() {
            const phase = this.getAttribute('data-phase');
            
            // Only allow navigation to completed phases or the next phase
            if (phase === 'setup' || APP_STATE.scenario.phases[phase] || isNextPhase(phase)) {
                navigateToPhase(phase);
            } else {
                showMessage('Please complete the previous phases first.', 'warning');
            }
        });
    });
    
    // Export button
    document.getElementById('export-btn').addEventListener('click', function() {
        showExportOptions();
    });
    
    // Exercise mode button
    document.getElementById('exercise-mode-btn').addEventListener('click', function() {
        toggleExerciseMode();
    });
    
    // Test API connection button
    document.getElementById('test-api-btn').addEventListener('click', function() {
        testApiConnection();
    });
}

/**
 * Initialize all application modules
 */
function initializeModules() {
    setupModule.init();
    apiModule.init();
    phasesModule.init();
    injectsModule.init();
    exportModule.init();
}

/**
 * Load a phase into the main content area
 * @param {string} phaseId - The ID of the phase to load
 */
function loadPhase(phaseId) {
    APP_STATE.currentPhase = phaseId;
    
    // Update active state in sidebar
    document.querySelectorAll('.phase-item').forEach(item => {
        item.classList.remove('active');
    });
    document.querySelector(`.phase-item[data-phase="${phaseId}"]`).classList.add('active');
    
    // Clear the phase content
    const phaseContent = document.getElementById('phase-content');
    phaseContent.innerHTML = '';
    
    // Load the appropriate phase content
    if (phaseId === 'setup') {
        // Load setup phase template
        const template = document.getElementById('setup-phase-template');
        phaseContent.appendChild(document.importNode(template.content, true));
        
        // Initialize setup phase
        setupModule.initPhase();
    } else {
        // Load standard phase template and customize it
        const template = document.getElementById('phase-template');
        const content = document.importNode(template.content, true);
        
        // Update phase-specific content
        content.querySelector('h2').textContent = `${PHASES[phaseId].name} Phase`;
        content.querySelector('.phase-header p').textContent = PHASES[phaseId].description;
        
        // Add phase-specific class
        content.querySelector('.phase-content').classList.add(`${phaseId}-phase`);
        
        // Append to the DOM
        phaseContent.appendChild(content);
        
        // Initialize the phase
        phasesModule.initPhase(phaseId);
    }
}

/**
 * Navigate to a specific phase
 * @param {string} phaseId - The ID of the phase to navigate to
 */
function navigateToPhase(phaseId) {
    APP_STATE.navigationHistory.push(APP_STATE.currentPhase);
    loadPhase(phaseId);
}

/**
 * Navigate to the previous phase
 */
function navigateToPreviousPhase() {
    const previousPhase = APP_STATE.navigationHistory.pop();
    if (previousPhase) {
        loadPhase(previousPhase);
    } else {
        // If no previous phase, go to setup
        loadPhase('setup');
    }
}

/**
 * Check if a phase is the next phase to complete
 * @param {string} phaseId - The ID of the phase to check
 * @returns {boolean} - Whether the phase is the next one
 */
function isNextPhase(phaseId) {
    const phaseOrder = ['setup', 'identification', 'containment', 'eradication', 'recovery', 'hardening'];
    const currentIndex = phaseOrder.indexOf(APP_STATE.currentPhase);
    const targetIndex = phaseOrder.indexOf(phaseId);
    
    return targetIndex === currentIndex + 1;
}

/**
 * Get the ID of the next phase
 * @returns {string} - The ID of the next phase
 */
function getNextPhase() {
    const phaseOrder = ['setup', 'identification', 'containment', 'eradication', 'recovery', 'hardening'];
    const currentIndex = phaseOrder.indexOf(APP_STATE.currentPhase);
    
    if (currentIndex < phaseOrder.length - 1) {
        return phaseOrder[currentIndex + 1];
    }
    
    return null;
}

/**
 * Update the scenario summary in the sidebar
 */
function updateScenarioSummary() {
    const summary = document.getElementById('scenario-params-summary');
    
    // If no scenario parameters, show default message
    if (!APP_STATE.scenario.params.organizationSector) {
        summary.innerHTML = '<p>No scenario configured yet</p>';
        return;
    }
    
    // Create summary HTML
    let html = `
        <div class="summary-item">
            <div class="summary-label">Organization:</div>
            <div class="summary-value">${APP_STATE.scenario.params.organizationSector} (${APP_STATE.scenario.params.organizationSize})</div>
        </div>
        <div class="summary-item">
            <div class="summary-label">Threat:</div>
            <div class="summary-value">${APP_STATE.scenario.params.attackType} by ${APP_STATE.scenario.params.threatActor}</div>
        </div>
        <div class="summary-item">
            <div class="summary-label">Teams:</div>
            <div class="summary-value">${getTeamsString()}</div>
        </div>
        <div class="summary-item">
            <div class="summary-label">Difficulty:</div>
            <div class="summary-value">${APP_STATE.scenario.params.difficulty}</div>
        </div>
        <div class="summary-item">
            <div class="summary-label">Injects:</div>
            <div class="summary-value">${APP_STATE.scenario.injects.length} total</div>
        </div>
    `;
    
    summary.innerHTML = html;
}

/**
 * Get a string representation of the selected teams
 * @returns {string} - String describing selected teams
 */
function getTeamsString() {
    const teams = [];
    
    if (APP_STATE.scenario.params.teams && APP_STATE.scenario.params.teams.includes('irt')) {
        teams.push('IRT');
    }
    
    if (APP_STATE.scenario.params.teams && APP_STATE.scenario.params.teams.includes('cmt')) {
        teams.push('CMT');
    }
    
    return teams.join(' + ') || 'None selected';
}

/**
 * Show the export options modal
 */
function showExportOptions() {
    if (!APP_STATE.scenario.injects || APP_STATE.scenario.injects.length === 0) {
        showMessage('Please generate a scenario first before exporting.', 'warning');
        return;
    }
    
    showModal('Export Scenario', exportModule.getExportModalContent());
}

/**
 * Toggle exercise mode
 */
function toggleExerciseMode() {
    if (!APP_STATE.scenario.injects || APP_STATE.scenario.injects.length === 0) {
        showMessage('Please generate a scenario first before entering exercise mode.', 'warning');
        return;
    }
    
    document.body.classList.toggle('exercise-mode');
    
    const button = document.getElementById('exercise-mode-btn');
    if (document.body.classList.contains('exercise-mode')) {
        button.innerHTML = '<i class="fas fa-stop"></i> Exit Exercise Mode';
        // Hide sidebar on small screens
        if (window.innerWidth < 992) {
            document.querySelector('.sidebar').style.display = 'none';
            document.querySelector('.main-content').style.gridColumn = '1 / span 2';
        }
    } else {
        button.innerHTML = '<i class="fas fa-play"></i> Run Exercise';
        // Show sidebar again
        document.querySelector('.sidebar').style.display = '';
        document.querySelector('.main-content').style.gridColumn = '';
    }
}

/**
 * Show a loading spinner with a message
 * @param {string} message - The message to display
 */
function showLoading(message) {
    const overlay = document.getElementById('loading-overlay');
    const messageElement = document.getElementById('loading-message');
    
    messageElement.textContent = message || 'Loading...';
    overlay.classList.remove('hidden');
}

/**
 * Hide the loading spinner
 */
function hideLoading() {
    document.getElementById('loading-overlay').classList.add('hidden');
}

/**
 * Show a modal dialog
 * @param {string} title - The title of the modal
 * @param {string|HTMLElement} content - The content of the modal
 */
function showModal(title, content) {
    const modalContainer = document.getElementById('modal-container');
    const modalTitle = document.getElementById('modal-title');
    const modalContent = document.getElementById('modal-content');
    
    modalTitle.textContent = title;
    
    // Clear previous content
    modalContent.innerHTML = '';
    
    // Add new content
    if (typeof content === 'string') {
        modalContent.innerHTML = content;
    } else {
        modalContent.appendChild(content);
    }
    
    // Show the modal
    modalContainer.classList.remove('hidden');
    
    // Add event listener to close modal when clicking outside
    modalContainer.addEventListener('click', function(event) {
        if (event.target === modalContainer) {
            closeModal();
        }
    });
}

/**
 * Close the modal dialog
 */
function closeModal() {
    document.getElementById('modal-container').classList.add('hidden');
}

/**
 * Show a message to the user
 * @param {string} message - The message to display
 * @param {string} type - The type of message (success, error, warning, info)
 */
function showMessage(message, type = 'info') {
    // Create or get a message container
    let messageContainer = document.getElementById('message-container');
    
    if (!messageContainer) {
        messageContainer = document.createElement('div');
        messageContainer.id = 'message-container';
        messageContainer.style.position = 'fixed';
        messageContainer.style.top = '10px';
        messageContainer.style.right = '10px';
        messageContainer.style.zIndex = '9999';
        document.body.appendChild(messageContainer);
    }
    
    // Create message element
    const messageElement = document.createElement('div');
    messageElement.className = `message message-${type}`;
    messageElement.innerHTML = `
        <div class="message-content">
            <i class="fas ${getIconForMessageType(type)}"></i>
            <span>${message}</span>
        </div>
        <button class="message-close"><i class="fas fa-times"></i></button>
    `;
    
    // Style the message
    messageElement.style.backgroundColor = getColorForMessageType(type);
    messageElement.style.color = '#fff';
    messageElement.style.padding = '10px 15px';
    messageElement.style.borderRadius = '4px';
    messageElement.style.marginBottom = '10px';
    messageElement.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
    messageElement.style.display = 'flex';
    messageElement.style.justifyContent = 'space-between';
    messageElement.style.alignItems = 'center';
    messageElement.style.minWidth = '250px';
    messageElement.style.maxWidth = '350px';
    
    // Add close button functionality
    const closeButton = messageElement.querySelector('.message-close');
    closeButton.style.background = 'none';
    closeButton.style.border = 'none';
    closeButton.style.color = '#fff';
    closeButton.style.cursor = 'pointer';
    closeButton.style.fontSize = '1rem';
    
    closeButton.addEventListener('click', function() {
        messageContainer.removeChild(messageElement);
    });
    
    // Add to container
    messageContainer.appendChild(messageElement);
    
    // Remove after delay
    setTimeout(() => {
        if (messageElement.parentNode === messageContainer) {
            messageContainer.removeChild(messageElement);
        }
    }, 5000);
}

/**
 * Get the Font Awesome icon class for a message type
 * @param {string} type - The type of message
 * @returns {string} - The icon class
 */
function getIconForMessageType(type) {
    switch (type) {
        case 'success': return 'fa-check-circle';
        case 'error': return 'fa-exclamation-circle';
        case 'warning': return 'fa-exclamation-triangle';
        case 'info':
        default: return 'fa-info-circle';
    }
}

/**
 * Get the background color for a message type
 * @param {string} type - The type of message
 * @returns {string} - The color
 */
function getColorForMessageType(type) {
    switch (type) {
        case 'success': return '#2ECC71';
        case 'error': return '#E74C3C';
        case 'warning': return '#F39C12';
        case 'info':
        default: return '#3498DB';
    }
}

/**
 * Toggle a collapsible panel
 * @param {HTMLElement} element - The header element of the panel
 */
function toggleCollapsible(element) {
    const panel = element.parentElement;
    panel.classList.toggle('collapsed');
    
    // Change the icon
    const icon = element.querySelector('i');
    if (panel.classList.contains('collapsed')) {
        icon.className = 'fas fa-chevron-right';
    } else {
        icon.className = 'fas fa-chevron-down';
    }
}

/**
 * Toggle a team selection
 * @param {HTMLElement} element - The team option element
 */
function toggleTeamSelection(element) {
    element.classList.toggle('selected');
}

/**
 * Format a date for display
 * @param {Date|string} date - The date to format
 * @returns {string} - The formatted date
 */
function formatDate(date) {
    const d = new Date(date);
    return d.toLocaleDateString() + ' ' + d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
}

/**
 * Test the API connection
 */
async function testApiConnection() {
    try {
        // Save current API settings
        saveApiSettings();
        
        // Show loading
        showLoading('Testing API connection...');
        
        // Test the connection
        const result = await apiModule.testConnection();
        
        // Hide loading
        hideLoading();
        
        if (result.success) {
            showMessage('API connection successful!', 'success');
        } else {
            showMessage(`API connection failed: ${result.error}`, 'error');
        }
    } catch (error) {
        hideLoading();
        showMessage(`API connection failed: ${error.message}`, 'error');
    }
}

// Expose global functions
window.toggleCollapsible = toggleCollapsible;
window.toggleTeamSelection = toggleTeamSelection;
window.closeModal = closeModal;
window.navigateToPhase = navigateToPhase;
window.formatDate = formatDate;